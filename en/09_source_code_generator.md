# 9. Source Code Generator

mapper-generator is an sbt plugin which generates ScalikeJDBC code from an existing database.

[https://github.com/scalikejdbc/scalikejdbc/tree/master/scalikejdbc-mapper-generator](https://github.com/scalikejdbc/scalikejdbc/tree/master/scalikejdbc-mapper-generator)

## Preparation

### project/scalikejdbc-gen.sbt

Add the sbt plugin in the sbt setting file. Don't forget adding a JDBC driver to libraryDependencies.

    libraryDependencies += "org.hsqldb" % "hsqldb" % "2.+"
    addSbtPlugin("org.scalikejdbc" %% "scalikejdbc-mapper-generator" % "3.2.+")

### project/scalikejdbc.properties

The filename and the place to put it is unchangable. Use the following template and put it under project directory.

    # JDBC Connectivity Settings
    jdbc.driver=org.hsqldb.jdbc.JDBCDriver
    jdbc.url=jdbc:hsqldb:file:db/test
    jdbc.username=sa
    jdbc.password=
    jdbc.schema=
    # The package name to put the generated classes
    generator.packageName=models
    # Line Break: LF/CRLF
    generator.lineBreak=LF
    # Template Type: basic/namedParameters/executable/interpolation/queryDsl
    generator.template=queryDsl
    # Test Template Type: specs2unit/specs2acceptance/ScalaTestFlatSpec
    generator.testTemplate=specs2unit
    # Charset
    generator.encoding=UTF-8
    # Use scalikejdbc-syntax-support-macro if true: true/false
    generator.autoConstruct
    # Add default parameter of DBSession implicit parameter if true: true/false
    generator.defaultAutoSession
    # Class name to represent date time value: org.joda.time.DateTime/java.time.ZonedDateTime/java.time.OffsetDateTime
    generator.dateTimeClass

### build.sbt

Adding `enablePlugins(ScalikejdbcPlugin)` enables `scalikejdbcGen` command.

    enablePlugins(ScalikejdbcPlugin)

## How to use

The usage is quite simple. Run the `scalikejdbcGen` with the table name to load and the class name to generate if necessary.

    sbt "scalikejdbcGen [table-name (class-name)]"

When you have `operation_history` table and run `scalikejdbcGen operation_history`, the code generator generates `src/main/scala/models/OperationHistory.scala` and `src/test/scala/models/OperationHistorySpec.scala`.

If you're working on a project which follows the naming convention of Ruby on Rails' ActiveRecord, run `scalikejdbcGen operation_histories OperationHistory`. If you don't specify the class name, `OperationHistories.scala` and `OperationHistoriesSpec.scala` are generated. Furthermore, if you specify GeneratorSettings's tableNameToClassName in sbt settings, you can specify your original naming conventions.

## Generated Code

I know it's a bit verbose but let me show you the actual code sample generated by mapper-generator. Test codes are auto generated. You can easily understand how to use the code by reading the tests.

If you have a table:

    create table member (
      id int generated always as identity,
      name varchar(30) not null,
      description varchar(1000),
      birthday date,
      created_at timestamp not null,
      primary key(id)
    )

running `scalikejdbcGen member` generates the following code.

### src/main/scala/com/example/Member.scala

The following code is generated by the following configuration.

- generator.template: queryDsl
- generator.packageName: com.example
```
    package models

    import scalikejdbc._
    import org.joda.time.{LocalDate, DateTime}

    case class Member(
      id: Int,
      name: String,
      description: Option[String] = None,
      birthday: Option[LocalDate] = None,
      createdAt: DateTime) {

      def save()(implicit session: DBSession = Member.autoSession): Member = Member.save(this)(session)

      def destroy()(implicit session: DBSession = Member.autoSession): Unit = Member.destroy(this)(session)

    }


    object Member extends SQLSyntaxSupport[Member] {

      override val tableName = "MEMBER"

      override val columns = Seq("ID", "NAME", "DESCRIPTION", "BIRTHDAY", "CREATED_AT")

      def apply(m: ResultName[Member])(rs: WrappedResultSet): Member = new Member(
        id = rs.int(m.id),
        name = rs.string(m.name),
        description = rs.stringOpt(m.description),
        birthday = rs.dateOpt(m.birthday).map(_.toLocalDate),
        createdAt = rs.timestamp(m.createdAt).toDateTime
      )

      val m = Member.syntax("m")

      val autoSession = AutoSession

      def find(id: Int)(implicit session: DBSession = autoSession): Option[Member] = {
        withSQL {
          select.from(Member as m).where.eq(m.id, id)
        }.map(Member(m.resultName)).single.apply()
      }

      def findAll()(implicit session: DBSession = autoSession): List[Member] = {
        withSQL(select.from(Member as m)).map(Member(m.resultName)).list.apply()
      }

      def countAll()(implicit session: DBSession = autoSession): Long = {
        withSQL(select(sqls"count(1)").from(Member as m)).map(rs => rs.long(1)).single.apply().get
      }

      def findAllBy(where: SQLSyntax)(implicit session: DBSession = autoSession): List[Member] = {
        withSQL {
          select.from(Member as m).where.append(sqls"${where}")
        }.map(Member(m.resultName)).list.apply()
      }

      def countBy(where: SQLSyntax)(implicit session: DBSession = autoSession): Long = {
        withSQL {
          select(sqls"count(1)").from(Member as m).where.append(sqls"${where}")
        }.map(_.long(1)).single.apply().get
      }

      def create(
        name: String,
        description: Option[String] = None,
        birthday: Option[LocalDate] = None,
        createdAt: DateTime)(implicit session: DBSession = autoSession): Member = {
        val generatedKey = withSQL {
          insert.into(Member).columns(
            column.name,
            column.description,
            column.birthday,
            column.createdAt
          ).values(
            name,
            description,
            birthday,
            createdAt
          )
        }.updateAndReturnGeneratedKey.apply()

        Member(
          id = generatedKey.toInt,
          name = name,
          description = description,
          birthday = birthday,
          createdAt = createdAt)
      }

      def save(m: Member)(implicit session: DBSession = autoSession): Member = {
        withSQL {
          update(Member as m).set(
            m.id -> m.id,
            m.name -> m.name,
            m.description -> m.description,
            m.birthday -> m.birthday,
            m.createdAt -> m.createdAt
          ).where.eq(m.id, m.id)
        }.update.apply()
        m
      }

      def destroy(m: Member)(implicit session: DBSession = autoSession): Unit = {
        withSQL { delete.from(Member).where.eq(column.id, m.id) }.update.apply()
      }

    }
```
### src/test/scala/com/example/MemberSpec.scala

The following code is generated by the following configuration. It's also possible to generate ScalaTest code.

- generator.testTemplate: specs2unit
```
    package models

    import scalikejdbc.specs2.mutable.AutoRollback
    import org.specs2.mutable._
    import org.joda.time._

    class MemberSpec extends Specification {

      "Member" should {
        "find by primary keys" in new AutoRollback {
          val maybeFound = Member.find(123)
          maybeFound.isDefined should beTrue
        }
        "find all records" in new AutoRollback {
          val allResults = Member.findAll()
          allResults.size should be_>(0)
        }
        "count all records" in new AutoRollback {
          val count = Member.countAll()
          count should be_>(0L)
        }
        "find by where clauses" in new AutoRollback {
          val results = Member.findAllBy(sqls.eq(m.id, 123))
          results.size should be_>(0)
        }
        "count by where clauses" in new AutoRollback {
          val count = Member.countBy(sqls.eq(m.id, 123))
          count should be_>(0L)
        }
        "create new record" in new AutoRollback {
          val created = Member.create(name = "MyString", createdAt = DateTime.now)
          created should not beNull
        }
        "save a record" in new AutoRollback {
          val entity = Member.findAll().head
          val updated = Member.save(entity)
          updated should not equalTo(entity)
        }
        "destroy a record" in new AutoRollback {
          val entity = Member.findAll().head
          Member.destroy(entity)
          val shouldBeNone = Member.find(123)
          shouldBeNone.isDefined should beFalse
        }
      }

    }
```
